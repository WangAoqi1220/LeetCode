题干：
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:
每个数组中的元素不会超过 100
数组的大小不会超过 200
示例 1:
输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].
 
示例 2:
输入: [1, 2, 3, 5]
输出: false
解释: 数组不能分割成两个元素和相等的子集.

解法：
运用动态规划，当数组长度小于2时返回false，当数组和为奇数或者数组最大值大于数组一半时返回false，创建一个dp二维数组，包含n行target+1列，其中dp[i][j]表示从数组的[0,i]下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于j初始时，dp中的全部元素都是false。
在定义状态之后，需要考虑边界情况。以下两种情况都属于边界情况。
如果不选取任何正整数，则被选取的正整数等于0。因此对于所有0≤i<n，都有dp[i][0]=true。
当i==0时，只有一个正整数nums[0]可以被选取，因此dp[0][nums[0]]=true。
对于i>0且j>0的情况，如何确定dp[i][j]的值？需要分别考虑以下两种情况。
如果j≥nums[i]，则对于当前的数字nums[i]，可以选取也可以不选取，两种情况只要有一个为true，就有dp[i][j]=true。
如果不选取nums[i]，则dp[i][j]=dp[i−1][j]；
如果选取nums[i]，则dp[i][j]=dp[i−1][j−nums[i]]。
如果j<nums[i]，则在选取的数字的和等于j的情况下无法选取当前的数字nums[i]，因此有dp[i][j]=dp[i−1][j]。
最后返回dp[n−1][target] 