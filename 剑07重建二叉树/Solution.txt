题干：
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如，给出
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7

解法：
前序遍历集合[3,9,20,15,7]中第一个元素3一定是根节点，9一定在3的子树上，但无法确认是左右子树，后续元素更无法确认。
中序遍历集合[9,3,15,20,7]出现顺序是：左子树、根节点、右子树，根节点将左右子树分开，分别居左右。
我们知道3一定在根节点上，那就在中序遍历集合中找到3,3左边元素一定位于左子树，3右边元素一定位于右子树。
那就很好处理了，我们对preorder定义指针preIndex，初始化0，表示位于preorder最左边；再对inorder定义左右双指针（inLeft、inRight），依次指向inorder左右两侧。
基于preorder[preIndex]生成TreeNode，指针preIndex右移，同时在inorder区间[inLeft,inRight]找到preorder[preIndex]索引l。
若l - inleft > 0,表示左子树还存在元素，继续递归生成根左子树；若inRight - l > 0,表示右子树还存在元素，继续递归生成右子树。
需要注意的是由于preIndex是inorder遍历指针，所有每次递归后都需要变化，故使用ref。