题干：
输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。
示例1：
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
限制：
0 <= 链表长度 <= 1000

解法：
链表l1,l2是递增的，因此容易想到使用双指针l1和l2遍历两链表，根据l1.val和l2.val的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。
引入伪头节点： 由于初始状态合并链表中无节点，因此循环第一轮时无法将节点添加到合并链表中。解决方案：初始化一个辅助节点 dum 作为合并链表的伪头节点，将各节点添加至 dum 之后。
初始化： 伪头节点dum，节点cur指向dum。
循环合并：当l1或l2为空时跳出：
1.当l1.val < l2.val时：cur的后继节点指定为l1，并l1向前走一步；
2.当l1.val >= l2.val时：cur的后继节点指定为l2，并l2向前走一步；
3.节点cur向前走一步，即cur=cur.next。
合并剩余尾部： 跳出时有两种情况，即l1为空或l2为空
若l1=null ：将l1添加至节点 curcur 之后；
否则：l2添加至节点cur之后。
返回值：返回dum.next